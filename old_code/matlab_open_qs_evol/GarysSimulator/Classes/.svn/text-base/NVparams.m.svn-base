%Pulsefinding params for NV setup

global pulseguess
global Uwantin

%% Setup the spins and Hamiltonians


% construct the relevant spins
NV = Spin(1);
NV.Name = 'NV';

Nitrogen = Spin(1);
Nitrogen.Name = 'Nitrogen';

BField = Field([0 0 29e6/2.803448083560241e+06]); % field in Gauss
BField.Name = 'B';

% create a new Hamiltonian
Hnat = Hamiltonian();

% add the spins to the Hamiltonian
Hnat.addSpins(NV,Nitrogen);

% add the static field
Hnat.addField(BField);

% create the interactions

% Zero Field Splitting (Hz)
ZFS_NV = diag([0 0 2.87e9]);
Hnat.createInteraction('NV',[],'ZFS',ZFS_NV);

% Nuclear Quadrupole (Hz)
% NitrogenQuad = diag([1e2 0 -5e6]*2/3);
% Hnat.createInteraction('Nitrogen',[],'ZFS',NitrogenQuad);

% Nuclear Zeeman (Hz/G)
% gammaN14 = 3.0766e6/1e4*eye(3);
% Hnat.createInteraction('Nitrogen','B','Zeeman',gammaN14);

% Electron Zeeman (Hz/G)
gub = 1e-4*(9.27400915e-24/6.62606896e-34)*2.003*eye(3);
Hnat.createInteraction('NV','B','Zeeman',gub);

% add hyperfine (Hz)
A_NV_N = diag([2.1 2.1 2.3]*1e6);
Hnat.createInteraction('NV','Nitrogen','Hyperfine',A_NV_N);

% use the defined interactions to create a full, exact Hamiltonian
Hnat.createFullHamiltonian();

% take the secular approximaiton of the Hamiltoninan with energy define by
% the NV
Hnat.SecularHamiltonian = Hnat.createZeroHamiltonian('NV');

% Define the interaction/rotating frame
Hnat.InteractionFrameOperator = Hnat.expandOperator('NV',NV.Sz*NV.Sz);
Hnat.InteractionFrameEnergy = 2.899e+09;

Hnat.toggleInteractionFrame(Hnat.SecularHamiltonian);

%% Setup the params structure 

%Reset the params structure
params = [];

%Number of timesteps
params.plength = 250;

%Length of each time step
params.timestep = 2e-9;

%Initial stepsize (this is reasonably important - run some tries
%and choose a value which is close to what the program is choosing
%after 50 or so iterations)
params.stepsize =4;

%Desired unitary
tmpNVwant = eye(3); tmpNVwant([1 2],[1 2]) = (1/sqrt(2))*[1 -1i;-1i 1];

params.Uwant = kron(tmpNVwant,eye(3));

%params.Uwant = Uwantin;

params.subsystem{1} = [1 2];

params.subsys_weight = [1];

%Desired fidelity for the unitary (this is the trace squared fidelity F = abs(Ugoal^dagger*Usim)^2/N^2)
params.fidelity = 0.999;

%RF distribution to optimize over (will slow down search and convergence dramatically)
%Two dimensional array first column is percentage of sample; second
%column is percentage of rf strength it sees. 
%params.rfdist = [0.3 0.97;.4 1.00;0.3 1.03];

params.rfdist = [1 1];

%Hamiltonian distribution to optimize over
%params.Hamdist = (1/8)*ones(1,8);

params.Hamdist = [1];

%Matrices for robustness to Hamiltonian distributions.  These will be
%multiplied by 2PI and added to the natural Hamiltonian.
params.Hammatts{1} = 0;

%RF control fields (3D array of control Hamiltonians - as many as you like)
params.RFmatts(:,:,1) = Hnat.expandOperator('NV',NV.Sx);
params.RFmatts(:,:,2) = Hnat.expandOperator('NV',NV.Sy);

%Natural Hamiltonian
params.HNAT = 2*pi*Hnat.InteractionHamiltonian;

params.nbspins = 2;
params.HilbertDim = Hnat.HilbertDim();

%The maximum rf power for each rf field in rad/s
params.rfmax = 2*pi*[8e6 8e6];

%Some parameters for the random guess 
%Scale of the random guess for each RFmatt (between 0 and 1)
params.randscale = [0.05 0.05];

%Choose every randevery points at random (rest will be fit to cubic spline)
params.randevery = 25;

%Tolerance for improving i.e. if over 20 tries we are not improving by an average of at least this, 
%we will try a new random starting point
params.improvechk = 1e-7;

%Minimum stepsize (if we're not moving anywhere we should stop searching)
params.minstepsize = 1e-7;

%Number of random guesses to try before giving up
params.numtry = 1;


%Soft pulse buffering delay (delays required before and after soft pulses.
%  (Since our time periods are usually greater than 350ns we could probably
    %try to use fast shapes)
params.softpulsebuffer = 0e-6;

%If there is a starting guess for the pulse load it in here (should
%be a structure
params.pulseguess = [pulseguess];

%The type of pulse we are searching for (1 for unitary, 2 for state
%to state)
params.searchtype = 1;

%Flag for whether you want to allow the time steps to vary
params.tstepflag = 0;

%Maximum length of pulse (rather soft boundary)
params.tpulsemax = 10e-3;

%Input and goal states for state to state
params.rhoin = [];
params.rhogoal = [];

%Allow Zfreedom or not
params.Zfreedomflag = 0;

%Parameter to force the beginnings and end of the pulse to zero
%with a penalty function
params.onofframps = 0;
params.onoff_numpts = 10;
params.onoff_param1 = 1e-3;
params.onoff_param2 = 0.25;

%Display every x seconds irrespective of how things are improved
params.dispevery = 60;
