Comparison between sparse and non sparse evaluation of propagator for memory and CPU time.

This was done manually so values are not averaged over many trial.
Values corresponds to the number of carbon from 0 to 4.
NV is of course reduced 1/2 spin.
Sparse cleaning treshold is 1e-14.
Trotter Expansion is 1e11.
Length of propagator is 1000;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%% Define all parameters %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reset the params structure
params = [];

%Hamiltonian
params.NVSpinNumber = 3/4;
params.numberOfCarbon = 0;
params.carbonDistRadius = 5;

%Load Data
LauncherHamiltonian(params.NVSpinNumber,params.numberOfCarbon,params.carbonDistRadius);
load('HnatData.mat') %Hamiltonian from simulator, variable HnatData

%MethodsGradient
params.optMethod = 'Conjugate'; %Optimization methods: 'Gradient', 'Conjugate', 'BFGS'
params.optType = 'Unitary'; %Optimization types :'Unitary', 'Transfer'
params.gradientOrder = 1; %Improvement is not assured for increased order

%pLength-Number of timesteps min:step:max
%timeStep-Length of each time step
params.maxpLength = 1000;
params.pLengthStep = 2;
params.minpLength = 1000; %Must be larger than 2
params.timeStep = 1e-9; %of the order of oscillations (1e-9 minimum experimental pulse generator 
%+ RWA resonance freq max)

%Maximum power
params.maxPower = 1e7; %5e6-1e7 maximum experimental power in Hz, must be positive
params.powerGradPenalty = 0; %about 1

%Some parameters for the random guess 
%initPulseScale-Max intensity of the random guess for RF pulse
%randPower-How random is the initial pulse [0,1]
params.randomPulseFlag = 0; %Disable random, if 0 sometimes block algorithm, if 1 works will often be best
params.initPulseScale = params.maxPower/5; %Only for random
params.randPower = 0.1;

%initStepSize-Initial stepsize
%minstepInterval-Minimum section interval (if we're not moving anywhere we should stop searching)
params.initStepSize = 1; % 1 is good
params.minStepInterval = 1e-2; %In percent of initStepSize

%Desired fidelity for the unitary (this is the trace squared fidelity
params.fidelity = 0.99;
params.improvechk = 0; %Tolerance for improving DIRECTION VARIATION in percent
params.lengthImprov = -1; %This condition stops the length loop if the fidelity
%starts decreasing more then this value (negative, -1 to disable)

%Control Matrix
NV = Spin(params.NVSpinNumber);
Nitrogen = Spin(1);
Carbon = Spin(1/2);
%Maxpower should be divided by number of controlMatS
params.ControlMats{1} = HnatData.expandOperator('NV',NV.Sx);
params.maxPower = params.maxPower/length(params.ControlMats);

%Input state
rhoin = HnatData.expandOperator('NV',diag([0 1]));
params.rhoin = rhoin/norm(rhoin,'fro');
clear rhoin

% %Output states (many goal possible)
% rhogoal = HnatData.expandOperator('NV',diag([1 0]));
% params.opGoal = rhogoal/norm(rhogoal,'fro');
% clear rhogoal
% 
% %Input state
% rhoin = kron(kron(diag([1 0]),eye(3)),diag([1 0])); %NV/Nitrogen/Carbon
% params.rhoin = rhoin/norm(rhoin,'fro');
% clear rhoin

% % Operator goal
gate = Gates();
params.opGoal = gate.Rotation2(HnatData,'NV',0,pi,0,0);
% params.opGoal = gate.CNOT(HnatData,'NV','Carbon1');

%Figure to be shown (state evolution)
params.watchSpin{1} = 'NV';
% params.watchSpin{2} = 'Nitrogen';
% params.watchSpin{2} = 'Carbon1';



