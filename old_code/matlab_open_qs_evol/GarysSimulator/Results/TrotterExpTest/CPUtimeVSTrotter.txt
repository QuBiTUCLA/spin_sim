Unitary calculation to test expm vs trotter product -> time vs trotter number
1000 unitary calculation average over 20 different pulses

CODE:
clear all;

%Load Settings
GrapeSettings; %Prepare all settings, get 'params'

%% Loading propagator

%Prepare propagator
propagator = PropagatorObj();
propagator.TimeStep = params.timeStep;

maxHnatValues = 1/(100*params.timeStep*params.maxpLength);
HnatData.RotatingMatrix(abs(HnatData.RotatingMatrix) < maxHnatValues) = 0;
%Above line for good sparse matrix, kill off too slow values
propagator.Hnat = sparse(HnatData.RotatingMatrix);
propagator.TimeLength = params.maxpLength;

for i=1:length(params.ControlMats)
    propagator.ControlMats{i} = sparse(params.ControlMats{i});
end
propagator.rhoIn = sparse(params.rhoin);

%% Start Expm vs Trotter expansion Test
%time vs trotter number
maxtrot = 20;
maxtrial = 20;
CPUtimeTrotter = zeros(maxtrot,1);
for trial = 1:maxtrial
    trial
    
    currentPulse = PulseObj([length(propagator.ControlMats) params.maxpLength]);
    currentPulse.Pulse = currentPulse.makeRandomPulse(0.1,params.maxPower);
    propagator.ControlFields = currentPulse;
    
    for trotter=1:maxtrot
        trotter
        propagator.precalculation(2^trotter);

        tic
        [Utrot,~]=propagator.unitary();
        CPUtimeTrotter(trotter)= CPUtimeTrotter(trotter) + toc;
    end
end
CPUtimeTrotter = CPUtimeTrotter/maxtrial;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%% Define all parameters %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reset the params structure
params = [];

%Hamiltonian
params.NVSpinNumber = 3/4;
params.numberOfCarbon = 1;
params.carbonDistRadius = 2;

%Load Data
LauncherHamiltonian(params.NVSpinNumber,params.numberOfCarbon,params.carbonDistRadius);
load('HnatData.mat') %Hamiltonian from simulator, variable HnatData

%MethodsGradient
params.optMethod = 'Conjugate'; %Optimization methods: 'Gradient', 'Conjugate', 'BFGS'
params.optType = 'Unitary'; %Optimization types :'Unitary', 'Transfer'
params.gradientOrder = 1; %Improvement is not assured for increased order

%pLength-Number of timesteps min:step:max
%timeStep-Length of each time step
params.maxpLength = 1000;
params.pLengthStep = 2;
params.minpLength = 1000; %Must be larger than 2
params.timeStep = 1e-9; %of the order of oscillations (1e-9 minimum experimental pulse generator 
%+ RWA resonance freq max)

%Maximum power
params.maxPower = 1e7; %5e6-1e7 maximum experimental power in Hz, must be positive
params.powerGradPenalty = 0; %about 1

%Some parameters for the random guess 
%initPulseScale-Max intensity of the random guess for RF pulse
%randPower-How random is the initial pulse [0,1]
params.randomPulseFlag = 0; %Disable random, if 0 sometimes block algorithm, if 1 works will often be best
params.initPulseScale = params.maxPower/5; %Only for random
params.randPower = 0.1;

%initStepSize-Initial stepsize
%minstepInterval-Minimum section interval (if we're not moving anywhere we should stop searching)
params.initStepSize = 1; % 1 is good
params.minStepInterval = 1e-2; %In percent of initStepSize

%Desired fidelity for the unitary (this is the trace squared fidelity
params.fidelity = 0.99;
params.improvechk = 0; %Tolerance for improving DIRECTION VARIATION in percent
params.lengthImprov = -1; %This condition stops the length loop if the fidelity
%starts decreasing more then this value (negative, -1 to disable)

%Control Matrix
NV = Spin(params.NVSpinNumber);
Nitrogen = Spin(1);
Carbon = Spin(1/2);
%Maxpower should be divided by number of controlMatS
params.ControlMats{1} = HnatData.expandOperator('NV',NV.Sx);
params.maxPower = params.maxPower/length(params.ControlMats);

%Input state
rhoin = HnatData.expandOperator('NV',diag([0 1]));
params.rhoin = rhoin/norm(rhoin,'fro');
clear rhoin

% %Output states (many goal possible)
% rhogoal = HnatData.expandOperator('NV',diag([1 0]));
% params.opGoal = rhogoal/norm(rhogoal,'fro');
% clear rhogoal
% 
% %Input state
% rhoin = kron(kron(diag([1 0]),eye(3)),diag([1 0])); %NV/Nitrogen/Carbon
% params.rhoin = rhoin/norm(rhoin,'fro');
% clear rhoin

% % Operator goal
gate = Gates();
params.opGoal = gate.Rotation2(HnatData,'NV',0,pi,0,0);
% params.opGoal = gate.CNOT(HnatData,'NV','Carbon1');

%Figure to be shown (state evolution)
params.watchSpin{1} = 'NV';
% params.watchSpin{2} = 'Nitrogen';
% params.watchSpin{2} = 'Carbon1';



