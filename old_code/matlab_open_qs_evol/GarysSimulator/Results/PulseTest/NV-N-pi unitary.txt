%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%% Define all parameters %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Reset the params structure
params = [];

%Hamiltonian
params.NVSpinNumber = 3/4;
params.numberOfCarbon = 0;
params.carbonDistRadius = 2;

%Load Data
LauncherHamiltonian(params.NVSpinNumber,params.numberOfCarbon,params.carbonDistRadius);
load('HnatData.mat') %Hamiltonian from simulator, variable HnatData

%MethodsGradient
params.optMethod = 'Conjugate'; %Optimization methods: 'Gradient', 'Conjugate', 'BFGS'
params.optType = 'Unitary'; %Optimization types :'Unitary', 'Transfer'
params.gradientOrder = 1; %Improvement is not assured for increased order

%pLength-Number of timesteps min:step:max
%timeStep-Length of each time step
params.maxpLength = 454;
params.pLengthStep = 2;
params.minpLength = 454; %Must be larger than 2
params.timeStep = 1e-9; %of the order of oscillations (1e-9 minimum experimental pulse generator 
%+ RWA resonance freq max)

%Maximum power
params.maxPower = 1e7; %5e6-1e7 maximum experimental power in Hz, must be positive
params.powerGradPenalty = 0; %about 1

%Some parameters for the random guess 
%initPulseScale-Max intensity of the random guess for RF pulse
%randPower-How random is the initial pulse [0,1]
params.randomPulseFlag = 0; %Disable random, if 0 sometimes block algorithm
params.initPulseScale = params.maxPower/5; %Only for random
params.randPower = 0.1;

%initStepSize-Initial stepsize
%minstepInterval-Minimum section interval (if we're not moving anywhere we should stop searching)
params.initStepSize = 1; % 1 is good
params.minStepInterval = 1e-2; %In percent of initStepSize

%Desired fidelity for the unitary (this is the trace squared fidelity
params.fidelity = 0.999;
params.improvechk = 0; %Tolerance for improving DIRECTION VARIATION in percent
params.lengthImprov = -1; %This condition stops the length loop if the fidelity
%starts decreasing more then this value (negative, -1 to disable)

%Control Matrix
NV = Spin(params.NVSpinNumber);
Nitrogen = Spin(1);
Carbon = Spin(1/2);
%Maxpower should be divided by number of controlMatS
params.ControlMats{1} = HnatData.expandOperator('NV',NV.Sx);
params.maxPower = params.maxPower/length(params.ControlMats);

%Input state
rhoin = HnatData.expandOperator('NV',diag([0 1]));
params.rhoin = rhoin/norm(rhoin,'fro');
clear rhoin

% %Output states (many goal possible)
% rhogoal = HnatData.expandOperator('NV',diag([1 0]));
% params.opGoal = rhogoal/norm(rhogoal,'fro');
% clear rhogoal

% %Input state
% rhoin = kron(kron(diag([1 0]),eye(3)),diag([1 0])); %NV/Nitrogen/Carbon
% % % rhoin = kron(diag([1 0]),diag([0 1 0]));
% params.rhoin = rhoin/norm(rhoin,'fro');
% clear rhoin

% % Operator goal
gate = Gates();
params.opGoal = gate.Rotation2(HnatData,'NV',0,pi,0,0);
% params.opGoal = gate.CNOT(HnatData,'NV','Carbon1');

%Figure to be shown (state evolution)
params.watchSpin{1} = 'NV';
% params.watchSpin{2} = 'Nitrogen';
% params.watchSpin{3} = 'Carbon1';



